# This template is rendered by
# apps.blender.resources.scenefileeditor.generate_blender_crop_file(),
# written to tempfile and passed as arg to blender.
import re
import sys
import bpy

try:
    argv = sys.argv[sys.argv.index("--") + 1:]
except ValueError:
    argv = []

class EngineWarning(bpy.types.Operator):
    bl_idname = "wm.engine_warning"
    bl_label = "Inform about not supported rendering engine"

    def execute(self, context):
        self.report({"ERROR"}, "Engine " + bpy.context.scene.render.engine + \
                               " not supported by Golem")
        return {"FINISHED"}

class ShowInformation(bpy.types.Operator):
    bl_idname = "wm.scene_information"
    bl_label = "Inform user about scene settings"

    def execute(self, context):
        self.report({"INFO"}, "Resolution: " +
                              str(bpy.context.scene.render.resolution_x) +
                               " x " +
                               str(bpy.context.scene.render.resolution_y))
        self.report({"INFO"}, "File format: " +
                               str(bpy.context.scene.render.file_extension))
        self.report({"INFO"}, "Filepath: " +
                              str(bpy.context.scene.render.filepath))
        self.report({"INFO"}, "Frames: " +
                              str(bpy.context.scene.frame_start) + "-" +
                              str(bpy.context.scene.frame_end) + ";" +
                              str(bpy.context.scene.frame_step))

        return {"FINISHED"}

if 'GPU' in argv:
    bpy.context.scene.cycles.device = 'GPU'

    # We know the hierarchy from best to worst explicitly
    for compute_device_type in ['CUDA', 'OPENCL', 'NONE']:
        try:
            bpy.context.user_preferences.system.compute_device_type = \
                compute_device_type
            break
        except TypeError:
            pass
    # As for compute_device, probe the system and select the last option
    # enumerated as legal options for "compute_device"
    try:
        bpy.context.user_preferences.system.compute_device = '_'
    except TypeError:
        _, error, _ = sys.exc_info()
    # above was a guaranteed exception, so error is set for sure
    error = str(error)
    if re.match('bpy_struct', error):
        possible_values_str = error[error.find('('):]
        possible_values = re.findall(r'\'(\S+)\'', possible_values_str)
        select_value = possible_values[-1]
        bpy.context.user_preferences.system.compute_device = select_value

bpy.utils.register_class(EngineWarning)
engine = bpy.context.scene.render.engine
if engine not in ("BLENDER_RENDER", "CYCLES"):
    bpy.ops.wm.engine_warning()

bpy.utils.register_class(ShowInformation)
bpy.ops.wm.scene_information()


for scene in bpy.data.scenes:

    scene.render.tile_x = 0
    scene.render.tile_y = 0
    scene.render.resolution_x = %(resolution_x)d
    scene.render.resolution_y = %(resolution_y)d
    scene.render.resolution_percentage = 100
    scene.render.use_border = True
    scene.render.use_crop_to_border = True
    scene.render.border_max_x = %(border_max_x)r
    scene.render.border_min_x = %(border_min_x)r
    scene.render.border_min_y = %(border_min_y)r
    scene.render.border_max_y = %(border_max_y)r
    scene.render.use_compositing = bool(%(use_compositing)r)

#and check if additional files aren't missing
bpy.ops.file.report_missing_files()
